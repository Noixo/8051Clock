C51 COMPILER V9.56.0.0   BMP280                                                            10/29/2017 01:41:24 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE BMP280
OBJECT MODULE PLACED IN .\Objects\bmp280.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE bmp280.c OPTIMIZE(9,SIZE) BROWSE MODP2 DEBUG OBJECTEXTEND TABS(2) OBJECT
                    -(.\Objects\bmp280.obj)

line level    source

   1          #include "bmp280.h"
   2          #include "i2c.h"
   3          #include "serial.h"
   4          
   5          //global variable to store value needed for pressure measurement
   6          long t_fine = 0;
   7          
   8          void bmpReset()
   9          {
  10   1        i2c_start();
  11   1        (void) i2c_device_id(bmp280, 0);
  12   1        i2c_write(0xE0);
  13   1        
  14   1        i2c_start();
  15   1        (void) i2c_device_id(bmp280, 0);
  16   1        i2c_write(0xB6);
  17   1        i2c_stop();
  18   1      }
  19          
  20          void bmpSet(unsigned char settings, unsigned char reg)
  21          {
  22   1        i2c_start();
  23   1        i2c_device_id(bmp280, 0);
  24   1        i2c_write(reg);
  25   1        
  26   1        //i2c_start();
  27   1        
  28   1        //i2c_device_id(bmp280, 0);
  29   1        i2c_write(settings);
  30   1        i2c_stop();
  31   1      }
  32          /*
  33          //convert to char array/struct
  34          void bmpCalibration()
  35          {
  36            char i;
  37            
  38            i2c_start();
  39              
  40            i2c_device_id(bmp280, 0);
  41              
  42            i2c_write(0x88);
  43              
  44            //quick start
  45            i2c_start();
  46            i2c_device_id(bmp280, 1);
  47            
  48            for(i = 0; i < 12; i++)
  49            {
  50              serial_convert(i2c_read(0));
  51              serial_convert(i2c_read(0));
  52            }
  53            
  54            i2c_read(1);
C51 COMPILER V9.56.0.0   BMP280                                                            10/29/2017 01:41:24 PAGE 2   

  55            
  56            i2c_stop();
  57          }
  58          */
  59          
  60          //must read temp before reading pressure
  61          //temp is stored as 3 bytes, (0xFA-0xFC)
  62          long bmp280GetTemp()
  63          {
  64   1        //Keil long = 4 bytes, int = 2
  65   1        static long adc_T = 0, var1 = 0, var2 = 0, T = 0;
  66   1      
  67   1        i2c_start();
  68   1        i2c_device_id(bmp280, 0);
  69   1      
  70   1        i2c_write(0xFA);
  71   1      
  72   1        i2c_start();
  73   1        
  74   1        i2c_device_id(bmp280, 1);
  75   1        
  76   1        //shove temperature data into a 4 byte variable
  77   1        adc_T = i2c_read(0);
  78   1        adc_T <<= 8;
  79   1        adc_T |= i2c_read(0);
  80   1        adc_T <<= 8;
  81   1        adc_T |= i2c_read(1);
  82   1        i2c_stop();
  83   1      
  84   1        //conversion formula takes 20 bits
  85   1        adc_T >>= 4;
  86   1          
  87   1        //32bit-fixed point formula from BMP280 documentation -pg45-46 (8.2)
  88   1        
  89   1        //try adc_T >> 3; then + 1 bit shift for adcT>>4
  90   1        var1 = ((((adc_T>>3) - ((long)dig_T1<<1))) * ((long)dig_T2)) >> 11;
  91   1        var2  = (((((adc_T>>4) - ((long)dig_T1)) * ((adc_T>>4) - ((long)dig_T1))) >> 12) * ((long)dig_T3)) >> 14
             -;
  92   1        
  93   1        t_fine = var1+var2;
  94   1        T = (t_fine*5+128) >> 8;
  95   1        
  96   1        return (T);
  97   1      }
  98          
  99          unsigned long bmp280GetPressure()
 100          {
 101   1        
 102   1        long var1 = 0, var2 = 0, adc_P = 0;
 103   1        unsigned long p;
 104   1      
 105   1        //t_fine = t_fine;
 106   1        //begin multi-byte data transfer
 107   1        i2c_start();
 108   1        (void) i2c_device_id(bmp280, 0);
 109   1        //start at 0xF7-0xF9
 110   1        //point to pressure data location
 111   1        i2c_write(0xF7);
 112   1        
 113   1        //repeated start
 114   1        i2c_start();
 115   1        (void) i2c_device_id(bmp280, 1);
C51 COMPILER V9.56.0.0   BMP280                                                            10/29/2017 01:41:24 PAGE 3   

 116   1        
 117   1        adc_P = i2c_read(0);
 118   1        adc_P <<= 8;
 119   1        adc_P |= i2c_read(0);
 120   1        adc_P <<= 8;
 121   1        adc_P |= i2c_read(1);
 122   1        
 123   1        i2c_stop();
 124   1        
 125   1        //only use 20 bits
 126   1        adc_P >>= 4;
 127   1        
 128   1        //pressure conversion formula from BMP280 documentation
 129   1        //32bit-fixed point conversion -pg 46
 130   1        
 131   1        var1 = (((long)t_fine) >> 1) - (long)64000;
 132   1        var2 = (((var1 >> 2) * (var1 >> 2)) >> 11) * ((long)dig_P6);
 133   1      
 134   1        var2 = var2 + ((var1 * ((long)dig_P5)) << 1);
 135   1        var2 = (var2 >> 2) + (((long)dig_P4) << 16);
 136   1        
 137   1        var1 = (((dig_P3 * (((var1 >> 2) * (var1 >> 2)) >> 13)) >> 3) + ((((long)dig_P2) * var1) >> 1)) >> 18;
 138   1        var1 = ((((32768 + var1)) * ((long) dig_P1)) >> 15);
 139   1      
 140   1        if(var1 == 0)
 141   1        {
 142   2          return '0';
 143   2        }
 144   1        p = (((unsigned long) (((long)1048576) - adc_P) - (var2 >> 12))) * 3125;
 145   1      
 146   1        if(p < 0x80000000)
 147   1        {
 148   2          p = (p << 1) / ((unsigned long)var1);
 149   2        }
 150   1        else
 151   1        {
 152   2          p = (p / (unsigned long)var1) * 2;
 153   2        }
 154   1        
 155   1        var1 = (((long) dig_P9) * ((long) (((p >> 3) * (p >> 3)) >> 13))) >> 12;
 156   1        var2 = (((long)(p >> 2)) * ((long) dig_P8)) >> 13;
 157   1      
 158   1        
 159   1        p = (unsigned long)((long)p + ((var1 + var2 + dig_P7) >> 4));
 160   1        //p = t_fine;
 161   1        
 162   1        //convert Pa to hPa
 163   1        //p /= 100;
 164   1        
 165   1        return p;
 166   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1232    ----
   CONSTANT SIZE    =     25    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     20      18
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.

C51 COMPILER V9.56.0.0   BMP280                                                            10/29/2017 01:41:24 PAGE 4   


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
